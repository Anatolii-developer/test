<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Облік практики - Admin</title>
  <link rel="stylesheet" href="admin-styles.css" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet" />
  <style>
    .progress-shell {
      width: min(1100px, calc(100% - 48px));
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .progress-card {
      background: #fffef9;
      border-radius: 24px;
      padding: 32px 40px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .progress-header h1 {
      margin: 0 0 6px;
      font-size: 28px;
    }

    .progress-header p {
      margin: 0;
      color: #5a5a5a;
    }

    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-top: 20px;
    }

    .filters-grid label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      font-weight: 600;
      color: #333;
    }

    .filters-grid input,
    .filters-grid select {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #e37009;
      background: #fffef9;
      font-size: 14px;
      font-family: inherit;
    }

    .filters-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 16px;
    }

    .filters-actions .top-btn {
      height: 40px;
      padding: 0 18px;
    }

    .filters-actions .top-btn.secondary {
      background-color: #888;
    }

    .progress-status {
      margin-top: 14px;
      font-weight: 500;
      color: #8a5b2f;
    }

    .progress-status.error {
      color: #a31d1d;
    }

    .progress-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-top: 10px;
      font-weight: 500;
    }

    .progress-summary span {
      color: #5a5a5a;
    }

    .progress-summary strong {
      color: #1f1f1f;
    }

    .progress-filter-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .progress-filter-chip {
      padding: 4px 10px;
      border-radius: 999px;
      background: #f6e7d6;
      color: #9d4c06;
      font-size: 12px;
      font-weight: 500;
    }

    .progress-note {
      margin: 0;
      font-size: 12px;
      color: #6e6e6e;
    }

    .progress-table,
    .course-table {
      margin-top: 18px;
    }

    .section-title {
      margin: 0 0 12px;
      font-size: 20px;
    }

    .empty-state {
      margin-top: 12px;
      color: #7a7a7a;
      font-size: 14px;
    }

    .unit-modal-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 12px;
      font-size: 12px;
      font-weight: 600;
      color: #333;
    }

    .unit-modal-field input[type="number"] {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #e37009;
      background: #fffef9;
      font-size: 14px;
      font-family: inherit;
    }

    .unit-modal-hint {
      margin-top: 4px;
      font-size: 12px;
      color: #6e6e6e;
    }

    .unit-modal-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    .unit-modal-actions .top-btn {
      height: 40px;
      padding: 0 18px;
    }

    @media (max-width: 720px) {
      .progress-card {
        padding: 24px;
      }
    }
  </style>
</head>
<body class="with-sidebar">
  <aside class="sidebar" id="sidebar"></aside>

  <main class="admin-main">
    <div class="progress-shell">
      <div class="progress-card">
        <div class="progress-header">
          <h1>Облік практики</h1>
          <p>Оберіть курс і коригуйте юніти для всіх учасників.</p>
        </div>

        <div class="filters-grid">
          <label>
            Пошук курсу
            <input type="text" id="courseSearch" placeholder="Назва курсу" />
          </label>
          <label>
            Курс
            <select id="courseSelect">
              <option value="">Оберіть курс</option>
            </select>
          </label>
        </div>

        <div class="progress-status" id="progressStatus"></div>

        <div class="progress-summary" id="courseSummary">
          <span>Курс: <strong id="activeCourseTitle">—</strong></span>
          <span>Період: <strong id="activeCourseDates">—</strong></span>
        </div>

        <div class="progress-table">
          <table class="requests-table" aria-label="Course progress">
            <thead>
              <tr>
                <th>Тип активності</th>
                <th>Всього</th>
                <th>Проведено</th>
                <th>Пройдено</th>
                <th>Корекція</th>
              </tr>
            </thead>
            <tbody id="courseProgressBody">
              <tr>
                <td colspan="5">Оберіть курс для перегляду.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="progress-card">
        <h2 class="section-title">Учасник курсу</h2>
        <div class="filters-grid">
          <label>
            Пошук учасника
            <input type="text" id="participantSearch" placeholder="Імʼя або email" />
          </label>
          <label>
            Учасник
            <select id="participantSelect">
              <option value="">Оберіть учасника</option>
            </select>
          </label>
        </div>
        <div class="progress-summary" id="participantSummary">
          <span>Користувач: <strong id="participantName">—</strong></span>
          <span>Email: <strong id="participantEmail">—</strong></span>
        </div>
        <div class="course-table">
          <table class="requests-table" aria-label="Participant progress">
            <thead>
              <tr>
                <th>Тип активності</th>
                <th>Всього</th>
                <th>Проведено</th>
                <th>Пройдено</th>
                <th>Корекція</th>
              </tr>
            </thead>
            <tbody id="participantProgressBody">
              <tr>
                <td colspan="5">Оберіть учасника для перегляду.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="progress-card">
        <h2 class="section-title">Усі курси користувача</h2>
        <div class="filters-grid">
          <label>
            Пошук користувача
            <input type="text" id="globalUserSearch" placeholder="Імʼя користувача" />
          </label>
          <label>
            Користувач
            <select id="globalUserSelect">
              <option value="">Оберіть користувача</option>
            </select>
          </label>
        </div>
        <div class="progress-summary" id="globalUserSummary">
          <span>Користувач: <strong id="globalUserName">—</strong></span>
          <span>Email: <strong id="globalUserEmail">—</strong></span>
        </div>
        <div class="course-table">
          <table class="requests-table" aria-label="User progress">
            <thead>
              <tr>
                <th>Тип активності</th>
                <th>Всього</th>
                <th>Проведено</th>
                <th>Пройдено</th>
              </tr>
            </thead>
            <tbody id="globalUserProgressBody">
              <tr>
                <td colspan="4">Оберіть користувача для перегляду.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </main>

  <div id="unitEditModal" class="modal" style="display: none;">
    <div class="modal-content">
      <span class="modal-close" id="unitEditClose" aria-label="Закрити">&times;</span>
      <h3>Юніти курсу</h3>
      <p>Курс: <strong id="unitEditCourseTitle">—</strong></p>
      <p>Користувач: <strong id="unitEditUserName">—</strong></p>

      <label class="unit-modal-field">
        Юніти для курсу
        <input type="number" id="courseUnitsValue" min="0" step="0.25" placeholder="Напр. 1.5" />
      </label>
      <div class="unit-modal-hint" id="courseUnitsHint"></div>

      <label class="unit-modal-field">
        Юніти для користувача
        <input type="number" id="userUnitsValue" min="0" step="0.25" placeholder="Напр. 1.0" />
      </label>
      <div class="unit-modal-hint" id="userUnitsHint"></div>

      <label class="unit-modal-field" style="flex-direction: row; align-items: center; gap: 8px; font-weight: 500;">
        <input type="checkbox" id="clearUserUnits" />
        Очистити юніти для користувача
      </label>

      <div class="unit-modal-actions">
        <button class="top-btn secondary" type="button" id="unitEditCancel">Скасувати</button>
        <button class="top-btn" type="button" id="unitEditSave">Застосувати</button>
      </div>
    </div>
  </div>

  <div id="typeOverrideModal" class="modal" style="display: none;">
    <div class="modal-content">
      <span class="modal-close" id="typeOverrideClose" aria-label="Закрити">&times;</span>
      <h3>Корекція юнітів</h3>
      <p>Тип активності: <strong id="typeOverrideName">—</strong></p>
      <p>Розраховано: <strong id="typeOverrideComputed">—</strong></p>

      <label class="unit-modal-field">
        Проведено
        <input type="number" id="overrideTaughtValue" min="0" step="0.25" placeholder="Напр. 12" />
      </label>

      <label class="unit-modal-field">
        Пройдено
        <input type="number" id="overrideAttendedValue" min="0" step="0.25" placeholder="Напр. 28" />
      </label>

      <div class="unit-modal-actions">
        <button class="top-btn secondary" type="button" id="typeOverrideReset">Скинути корекцію</button>
        <button class="top-btn" type="button" id="typeOverrideSave">Застосувати</button>
      </div>
    </div>
  </div>

  <script>
    window.API_BASE = window.API_BASE || "https://cabinet.mamko-prof-supervision.com";
  </script>
  <script src="admin-auth.js"></script>
  <script>
    const API_BASE = window.API_BASE || "";

    const baseTypes = [
      { key: "Особистий аналіз", label: "Особистий аналіз" },
      { key: "Індивідуальна супервізія", label: "Індивідуальна супервізія" },
      { key: "Групова супервізія", label: "Групова супервізія" },
      { key: "Менторське заняття", label: "Менторське заняття" },
      { key: "Лекція", label: "Лекція" },
      { key: "Семінар", label: "Семінар" },
      { key: "Терапевтична група", label: "Терапевтична група" },
      { key: "Супервізійно-семінарське заняття", label: "Супервізійно-семінарське заняття" },
      { key: "Парна терапія", label: "Проведення парної терапії" },
      { key: "Лекторій", label: "Лекторій" },
      { key: "Конференція", label: "Конференція" },
    ];

    let allCourses = [];
    let allUsers = [];
    let usersById = new Map();
    let activeCourseId = null;
    let activeCourse = null;
    let courseParticipants = [];
    let activeUserId = null;
    let activeGlobalUserId = null;
    let activeCourseForEdit = null;
    let activeTypeForOverride = null;
    let activeOverrideScope = null;
    let lastCourseRows = { base: {}, display: {} };
    let lastUserRows = { base: {}, display: {} };
    let lastGlobalRows = { base: {}, display: {} };

    document.addEventListener("DOMContentLoaded", () => {
      if (typeof renderAdminSidebar === "function") {
        renderAdminSidebar("admin-course-progress.html");
      }
      if (typeof requireAdminPage === "function") {
        requireAdminPage();
      }

      bindCourseControls();
      bindParticipantControls();
      bindGlobalUserControls();
      bindUnitModalActions();
      bindTypeOverrideModalActions();
      loadInitialData();
    });

    function bindCourseControls() {
      const search = document.getElementById("courseSearch");
      const select = document.getElementById("courseSelect");

      if (search) {
        search.addEventListener("input", () => {
          renderCourseOptions(search.value || "");
        });
      }
      if (select) {
        select.addEventListener("change", () => {
          activeCourseId = select.value || null;
          if (activeCourseId) {
            loadCourseDetails(activeCourseId);
          } else {
            resetCourseUI();
          }
        });
      }
    }

    function bindParticipantControls() {
      const search = document.getElementById("participantSearch");
      const select = document.getElementById("participantSelect");
      if (search) {
        search.addEventListener("input", () => {
          renderParticipantOptions(search.value || "");
        });
      }
      if (!select) return;
      select.addEventListener("change", () => {
        activeUserId = select.value || null;
        renderParticipantTable();
      });
    }

    function bindGlobalUserControls() {
      const search = document.getElementById("globalUserSearch");
      const select = document.getElementById("globalUserSelect");
      if (search) {
        search.addEventListener("input", () => {
          renderGlobalUserOptions(search.value || "");
        });
      }
      if (!select) return;
      select.addEventListener("change", () => {
        activeGlobalUserId = select.value || null;
        renderGlobalUserTable();
      });
    }

    async function loadInitialData() {
      setStatus("Завантаження курсів...");
      try {
        const fetcher = window.adminFetch
          ? window.adminFetch
          : (url) => fetch(url, { credentials: "include" });

        const coursesRes = await fetcher(`${API_BASE}/api/courses`);
        allCourses = coursesRes.ok ? await coursesRes.json() : [];
        let usersRes = await fetcher(`${API_BASE}/api/users/approved`);
        if (!usersRes.ok) {
          usersRes = await fetcher(`${API_BASE}/api/users`);
        }
        const usersData = usersRes.ok ? await usersRes.json() : [];
        allUsers = Array.isArray(usersData) ? usersData : [];
        indexUsers(allUsers);

        renderCourseOptions("");
        renderGlobalUserOptions("");
        setStatus("");
      } catch (err) {
        console.error("Помилка завантаження:", err);
        setStatus("Не вдалося завантажити курси.", true);
      }
    }

    function setStatus(text, isError) {
      const el = document.getElementById("progressStatus");
      if (!el) return;
      el.textContent = text || "";
      el.classList.toggle("error", Boolean(isError));
    }

    function renderCourseOptions(query) {
      const select = document.getElementById("courseSelect");
      if (!select) return;

      const current = select.value;
      const q = String(query || "").trim().toLowerCase();
      const filtered = allCourses
        .filter((course) => {
          const title = String(course.courseTitle || "").toLowerCase();
          return !q || title.includes(q);
        })
        .sort((a, b) => String(a.courseTitle || "").localeCompare(String(b.courseTitle || ""), "uk"));

      select.innerHTML = '<option value="">Оберіть курс</option>';
      filtered.forEach((course) => {
        const option = document.createElement("option");
        option.value = course._id || "";
        option.textContent = course.courseTitle || "Без назви";
        select.appendChild(option);
      });

      if (current && filtered.some((c) => String(c._id) === String(current))) {
        select.value = current;
      } else if (!current && filtered.length === 1) {
        select.value = filtered[0]._id || "";
      }

      activeCourseId = select.value || null;
      if (activeCourseId && String(activeCourse?._id || "") !== String(activeCourseId)) {
        loadCourseDetails(activeCourseId);
      }
    }

    async function loadCourseDetails(courseId) {
      if (!courseId) return;
      setStatus("Завантаження курсу...");
      try {
        const fetcher = window.adminFetch
          ? window.adminFetch
          : (url) => fetch(url, { credentials: "include" });
        const res = await fetcher(`${API_BASE}/api/courses/${courseId}`);
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          throw new Error(data.message || `HTTP ${res.status}`);
        }
        activeCourse = await res.json();
        activeCourseId = activeCourse._id || courseId;
        const participantsMap = new Map();
        if (Array.isArray(activeCourse.participants)) {
          activeCourse.participants.forEach((user) => {
            const id = normalizeId(user);
            if (id) participantsMap.set(id, resolveUser(user));
          });
        }
        if (Array.isArray(activeCourse.units)) {
          activeCourse.units.forEach((unit) => {
            if (!unit || !Array.isArray(unit.members)) return;
            unit.members.forEach((member) => {
              const id = courseProgressNormalizeId(member?.user);
              if (id && !participantsMap.has(id)) {
                participantsMap.set(id, resolveUser(member?.user));
              }
            });
          });
        }
        courseParticipants = Array.from(participantsMap.values());
        renderCourseSummary();
        renderCourseTable();
        renderParticipantOptions();
        renderParticipantTable();
        setStatus("");
      } catch (err) {
        console.error("Помилка завантаження курсу:", err);
        setStatus("Не вдалося завантажити курс.", true);
        resetCourseUI();
      }
    }

    function resetCourseUI() {
      activeCourse = null;
      courseParticipants = [];
      activeUserId = null;
      lastCourseRows = { base: {}, display: {} };
      lastUserRows = { base: {}, display: {} };

      const titleEl = document.getElementById("activeCourseTitle");
      const datesEl = document.getElementById("activeCourseDates");
      if (titleEl) titleEl.textContent = "—";
      if (datesEl) datesEl.textContent = "—";

      const courseBody = document.getElementById("courseProgressBody");
      if (courseBody) {
        courseBody.innerHTML = '<tr><td colspan="5">Оберіть курс для перегляду.</td></tr>';
      }
      const participantBody = document.getElementById("participantProgressBody");
      if (participantBody) {
        participantBody.innerHTML = '<tr><td colspan="5">Оберіть учасника для перегляду.</td></tr>';
      }
      const search = document.getElementById("participantSearch");
      if (search) {
        search.value = "";
        search.disabled = true;
      }
      renderParticipantOptions();
      updateParticipantSummary(null);
    }

    function renderGlobalUserOptions(query) {
      const search = document.getElementById("globalUserSearch");
      const select = document.getElementById("globalUserSelect");
      if (!select) return;
      const hasUsers = Boolean(allUsers.length);
      select.disabled = !hasUsers;
      if (search) search.disabled = !hasUsers;
      select.innerHTML = '<option value="">Оберіть користувача</option>';
      const q = String(query || "").trim().toLowerCase();
      const filtered = allUsers
        .slice()
        .filter((user) => {
          if (!q) return true;
          const label = getUserLabel(user).toLowerCase();
          const email = String(user?.email || "").toLowerCase();
          return label.includes(q) || email.includes(q);
        })
        .sort((a, b) => getUserLabel(a).localeCompare(getUserLabel(b), "uk"));

      filtered.forEach((user) => {
        const id = normalizeId(user);
        if (!id) return;
        const option = document.createElement("option");
        option.value = id;
        option.textContent = getUserLabel(user) || id;
        select.appendChild(option);
      });

      if (activeGlobalUserId && filtered.some((u) => normalizeId(u) === activeGlobalUserId)) {
        select.value = activeGlobalUserId;
      } else {
        activeGlobalUserId = "";
      }

      updateGlobalUserSummary(
        allUsers.find((u) => normalizeId(u) === activeGlobalUserId) || null
      );
    }

    function renderCourseSummary() {
      const titleEl = document.getElementById("activeCourseTitle");
      const datesEl = document.getElementById("activeCourseDates");
      if (titleEl) titleEl.textContent = activeCourse?.courseTitle || "—";
      if (datesEl) datesEl.textContent = formatCoursePeriod(activeCourse);
    }

    function renderParticipantOptions(query) {
      const search = document.getElementById("participantSearch");
      const select = document.getElementById("participantSelect");
      if (!select) return;
      const hasParticipants = Boolean(courseParticipants.length);
      select.disabled = !hasParticipants;
      if (search) search.disabled = !hasParticipants;
      select.innerHTML = '<option value="">Оберіть учасника</option>';
      const q = String(query || "").trim().toLowerCase();
      const filtered = courseParticipants
        .slice()
        .filter((user) => {
          if (!q) return true;
          const label = getUserLabel(user).toLowerCase();
          const email = String(user?.email || "").toLowerCase();
          return label.includes(q) || email.includes(q);
        })
        .sort((a, b) => getUserLabel(a).localeCompare(getUserLabel(b), "uk"));

      filtered
        .forEach((user) => {
        const id = normalizeId(user);
        if (!id) return;
        const option = document.createElement("option");
        option.value = id;
        option.textContent = getUserLabel(user) || id;
        select.appendChild(option);
      });
      if (activeUserId && filtered.some((u) => normalizeId(u) === activeUserId)) {
        select.value = activeUserId;
      } else {
        activeUserId = "";
      }
      updateParticipantSummary(
        courseParticipants.find((u) => normalizeId(u) === activeUserId) || null
      );
    }

    function getUserLabel(user) {
      if (!user) return "";
      if (typeof user === "string") return user;
      const fullName = [user.firstName, user.lastName].filter(Boolean).join(" ").trim();
      return fullName || user.fullName || user.username || user.email || "";
    }

    function normalizeId(value) {
      if (!value) return "";
      if (typeof value === "string") return value;
      if (typeof value === "object") return value._id || value.id || "";
      return "";
    }

    function indexUsers(users) {
      usersById = new Map();
      users.forEach((user) => {
        const id = normalizeId(user);
        if (id) usersById.set(String(id), user);
      });
    }

    function resolveUser(value) {
      const id = normalizeId(value);
      if (!id) return value;
      return usersById.get(String(id)) || value;
    }

    function getAuthHeaders() {
      let token = null;
      try {
        const u = JSON.parse(localStorage.getItem("user") || "null");
        token = u?.token || u?.accessToken || null;
      } catch (_) {}
      const h = { "Content-Type": "application/json" };
      if (token) h.Authorization = `Bearer ${token}`;
      return h;
    }

    function courseProgressNormalizeId(value) {
      if (!value) return null;
      if (typeof value === "string") return value;
      if (typeof value === "object") return value._id || value.id || null;
      return null;
    }

    function courseProgressIdsMatch(a, b) {
      const aId = courseProgressNormalizeId(a);
      const bId = courseProgressNormalizeId(b);
      return aId && bId && String(aId) === String(bId);
    }

    function courseProgressGetUnitMember(unit, userId) {
      if (!unit || !Array.isArray(unit.members)) return null;
      return unit.members.find((m) => courseProgressIdsMatch(m.user, userId)) || null;
    }

    function courseProgressGetUnitMode(unit, userId) {
      const member = courseProgressGetUnitMember(unit, userId);
      return member ? member.mode : null;
    }

    function courseProgressGetUnitAmount(unit, member) {
      const memberRaw = member?.amount;
      if (memberRaw !== null && memberRaw !== undefined && memberRaw !== "") {
        const memberAmount = Number(memberRaw);
        if (Number.isFinite(memberAmount)) return memberAmount;
      }
      return 1;
    }

    function courseProgressGetUnitBaseAmount(unit) {
      return 1;
    }

    function courseProgressGetDateOnly(value) {
      if (!value) return null;
      const date = value instanceof Date ? value : new Date(value);
      if (Number.isNaN(date.getTime())) return null;
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
    }

    function courseProgressGetWeekdayIndex(value) {
      if (!value) return null;
      const key = String(value).trim().toLowerCase().replace(/’/g, "'");
      const map = {
        "понеділок": 1,
        "вівторок": 2,
        "середа": 3,
        "четвер": 4,
        "п'ятниця": 5,
        "пятниця": 5,
        "субота": 6,
        "неділя": 0,
      };
      return Object.prototype.hasOwnProperty.call(map, key) ? map[key] : null;
    }

    function courseProgressGetCourseWeeks(course) {
      const startDate = courseProgressGetDateOnly(course?.courseDates?.start);
      const endDate = courseProgressGetDateOnly(course?.courseDates?.end);
      if (!startDate || !endDate || endDate < startDate) return null;
      const diffDays = Math.floor((endDate - startDate) / 86400000);
      const totalDays = diffDays + 1;
      const weeks = Math.round(totalDays / 7);
      return Math.max(1, weeks);
    }

    function courseProgressGetUnitOccurrences(unit, course) {
      if (!unit) return 0;
      const startDate = courseProgressGetDateOnly(course?.courseDates?.start);
      const endDate = courseProgressGetDateOnly(course?.courseDates?.end);

      if (unit.date) {
        const unitDate = courseProgressGetDateOnly(unit.date);
        if (!unitDate) return 0;
        if (startDate && unitDate < startDate) return 0;
        if (endDate && unitDate > endDate) return 0;
        return 1;
      }

      const weekdayIndex = courseProgressGetWeekdayIndex(unit.dayName || unit.day);
      if (startDate && endDate && weekdayIndex !== null) {
        const startDay = startDate.getUTCDay();
        const offset = (weekdayIndex - startDay + 7) % 7;
        const first = new Date(startDate.getTime());
        first.setUTCDate(first.getUTCDate() + offset);
        if (first > endDate) return 0;
        const diffDays = Math.floor((endDate - first) / 86400000);
        return Math.floor(diffDays / 7) + 1;
      }

      const weeks = courseProgressGetCourseWeeks(course);
      return weeks || 1;
    }

    function courseProgressFormatValue(value) {
      if (!Number.isFinite(value) || value <= 0) return "0";
      const rounded = Math.round(value * 100) / 100;
      if (Number.isInteger(rounded)) return String(rounded);
      return rounded.toFixed(2).replace(/\.?0+$/, "");
    }

    function courseProgressFormatShortDate(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
      return date.toLocaleDateString("uk-UA");
    }

    function courseProgressParseDate(value) {
      if (!value) return null;
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function courseProgressCourseMatchesFilters(course, filters) {
      if (!filters) return true;
      if (filters.category && course?.mainType !== filters.category) return false;

      if (filters.from || filters.to) {
        const endRaw = course?.courseDates?.end;
        const startRaw = course?.courseDates?.start;
        const dateRaw = endRaw || startRaw;
        const dateValue = dateRaw ? new Date(dateRaw) : null;
        if (!dateValue || Number.isNaN(dateValue.getTime())) return false;
        if (filters.from && dateValue < filters.from) return false;
        if (filters.to) {
          const endLimit = new Date(filters.to);
          endLimit.setHours(23, 59, 59, 999);
          if (dateValue > endLimit) return false;
        }
      }

      return true;
    }

    function courseProgressEnsureBucket(map, key, label) {
      if (!map[key]) {
        map[key] = { key, label, taught: 0, attended: 0 };
      }
      return map[key];
    }


    function extractPositiveNumber(value) {
      if (value === null || value === undefined || value === "") return null;
      const number = Number(value);
      return Number.isFinite(number) && number >= 0 ? number : null;
    }

    function getUniformUnits(values) {
      if (!values.length) return null;
      const first = values[0];
      if (values.every((v) => v === first)) return first;
      return null;
    }

    function normalizeProgressOverrides(raw) {
      if (!raw || typeof raw !== "object") return {};
      const normalized = {};
      Object.keys(raw).forEach((key) => {
        const entry = raw[key];
        if (!entry || typeof entry !== "object") return;
        const taught = extractPositiveNumber(entry.taught);
        const attended = extractPositiveNumber(entry.attended);
        if (taught === null && attended === null) return;
        const next = {};
        if (taught !== null) next.taught = taught;
        if (attended !== null) next.attended = attended;
        if (Object.keys(next).length) normalized[key] = next;
      });
      return normalized;
    }

    function applyProgressOverrides(rows, overrides) {
      if (!overrides || !Object.keys(overrides).length) return rows;
      const used = new Set();
      const updated = rows.map((row) => {
        const override = overrides[row.key];
        if (!override) return row;
        used.add(row.key);
        const next = Object.assign({}, row);
        if (Object.prototype.hasOwnProperty.call(override, "taught")) {
          next.taught = override.taught;
        }
        if (Object.prototype.hasOwnProperty.call(override, "attended")) {
          next.attended = override.attended;
        }
        return next;
      });

      Object.keys(overrides).forEach((key) => {
        if (used.has(key)) return;
        const override = overrides[key] || {};
        updated.push({
          key,
          label: key,
          taught: Object.prototype.hasOwnProperty.call(override, "taught") ? override.taught : 0,
          attended: Object.prototype.hasOwnProperty.call(override, "attended") ? override.attended : 0,
        });
      });

      return updated;
    }

    function openUnitEditModal(courseId) {
      const modal = document.getElementById("unitEditModal");
      if (!modal) return;

      const course =
        (activeCourse && String(activeCourse._id) === String(courseId) ? activeCourse : null) ||
        allCourses.find((c) => String(c._id) === String(courseId));
      if (!course) return;
      activeCourseForEdit = course;

      const titleEl = document.getElementById("unitEditCourseTitle");
      const userNameEl = document.getElementById("unitEditUserName");
      const courseInput = document.getElementById("courseUnitsValue");
      const userInput = document.getElementById("userUnitsValue");
      const courseHint = document.getElementById("courseUnitsHint");
      const userHint = document.getElementById("userUnitsHint");
      const clearUser = document.getElementById("clearUserUnits");

      const activeUser = courseParticipants.find((u) => normalizeId(u) === activeUserId);
      if (titleEl) titleEl.textContent = course.courseTitle || "—";
      if (userNameEl) userNameEl.textContent = activeUser ? getUserLabel(activeUser) : "—";

      const units = Array.isArray(course.units) ? course.units : [];
      const courseValues = units.map((unit) => extractPositiveNumber(unit?.hours));
      const courseAllHave = units.length > 0 && courseValues.every((v) => v !== null);
      const courseUniform = courseAllHave ? getUniformUnits(courseValues) : null;
      const courseHasSome = courseValues.some((v) => v !== null);

      if (courseInput) courseInput.value = courseUniform !== null ? courseUniform : "";
      if (courseHint) {
        if (!units.length) {
          courseHint.textContent = "У курсі немає юнітів.";
        } else if (courseUniform !== null) {
          courseHint.textContent = `Однакове значення у ${units.length} юнітах.`;
        } else if (courseHasSome) {
          courseHint.textContent = "У юнітах різні значення.";
        } else {
          courseHint.textContent = "Значення не задане.";
        }
      }

      const memberEntries = units
        .map((unit) => ({ unit, member: courseProgressGetUnitMember(unit, activeUserId) }))
        .filter((item) => item.member);
      const memberAmounts = memberEntries.map((item) => extractPositiveNumber(item.member?.amount));
      const userAllHave = memberEntries.length > 0 && memberAmounts.every((v) => v !== null);
      const userUniform = userAllHave ? getUniformUnits(memberAmounts) : null;
      const userHasSome = memberAmounts.some((v) => v !== null);

      if (userInput) userInput.value = userUniform !== null ? userUniform : "";
      if (userHint) {
        if (!activeUserId) {
          userHint.textContent = "Оберіть користувача, щоб змінити юніти.";
        } else if (!memberEntries.length) {
          userHint.textContent = "Користувач не доданий до юнітів курсу.";
        } else if (userUniform !== null) {
          userHint.textContent = `Однакове значення у ${memberEntries.length} юнітах.`;
        } else if (userHasSome) {
          userHint.textContent = `Різні значення у ${memberEntries.length} юнітах.`;
        } else {
          userHint.textContent = `Юніти з користувачем: ${memberEntries.length}.`;
        }
      }

      const allowUserEdit = Boolean(activeUserId && memberEntries.length);
      if (userInput) {
        userInput.disabled = !allowUserEdit;
        userInput.dataset.allowUser = allowUserEdit ? "1" : "0";
      }
      if (clearUser) {
        clearUser.checked = false;
        clearUser.disabled = !allowUserEdit;
      }

      modal.style.display = "flex";
    }

    function closeUnitEditModal() {
      const modal = document.getElementById("unitEditModal");
      if (!modal) return;
      modal.style.display = "none";
      activeCourseForEdit = null;
    }

    async function applyUnitOverrides() {
      if (!activeCourseForEdit) return;
      const courseInput = document.getElementById("courseUnitsValue");
      const userInput = document.getElementById("userUnitsValue");
      const clearUser = document.getElementById("clearUserUnits");
      const hasCourseInput = courseInput && String(courseInput.value || "").trim() !== "";
      const hasUserInput = userInput && String(userInput.value || "").trim() !== "";
      const courseValue = hasCourseInput ? extractPositiveNumber(courseInput.value) : null;
      const userValue = hasUserInput ? extractPositiveNumber(userInput.value) : null;

      if (hasCourseInput && courseValue === null) {
        alert("Некоректне значення для юнітів курсу.");
        return;
      }
      if (!clearUser?.checked && hasUserInput && userValue === null) {
        alert("Некоректне значення для юнітів користувача.");
        return;
      }

      const units = Array.isArray(activeCourseForEdit.units) ? activeCourseForEdit.units : [];
      if (!units.length) {
        alert("У курсі немає юнітів для оновлення.");
        return;
      }

      const updatedUnits = units.map((unit) => {
        const next = Object.assign({}, unit);
        if (courseValue !== null) next.hours = courseValue;

        if (activeUserId) {
          const members = Array.isArray(unit.members) ? unit.members.map((member) => {
            const userId = courseProgressNormalizeId(member?.user);
            if (!userId) return null;
            const mode = member?.mode === "проводив" ? "проводив" : "проходив";
            const existingAmount = extractPositiveNumber(member?.amount);
            const nextMember = { user: userId, mode };

            if (courseProgressIdsMatch(userId, activeUserId)) {
              if (clearUser?.checked) {
                return nextMember;
              }
              if (userValue !== null) {
                nextMember.amount = userValue;
              } else if (existingAmount !== null) {
                nextMember.amount = existingAmount;
              }
            } else if (existingAmount !== null) {
              nextMember.amount = existingAmount;
            }

            return nextMember;
          }).filter(Boolean) : [];
          if (members.length) next.members = members;
        }
        return next;
      });

      try {
        const fetcher = window.adminFetch
          ? window.adminFetch
          : (url, opts) => fetch(url, Object.assign({ credentials: "include" }, opts));
        const res = await fetcher(`${API_BASE}/api/courses/${activeCourseForEdit._id}`, {
          method: "PUT",
          headers: getAuthHeaders(),
          body: JSON.stringify({ units: updatedUnits }),
        });

        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          throw new Error(data.message || `HTTP ${res.status}`);
        }

        const updated = await res.json().catch(() => ({}));
        const index = allCourses.findIndex((c) => String(c._id) === String(activeCourseForEdit._id));
        if (index >= 0) {
          allCourses[index].units = Array.isArray(updated.units) ? updated.units : updatedUnits;
        }
        activeCourseForEdit.units = Array.isArray(updated.units) ? updated.units : updatedUnits;
        if (activeCourse && String(activeCourse._id) === String(activeCourseForEdit._id)) {
          activeCourse.units = activeCourseForEdit.units;
        }
        renderCourseTable();
        renderParticipantTable();
        closeUnitEditModal();
      } catch (err) {
        console.error("Помилка оновлення юнітів:", err);
        alert(err.message || "Помилка оновлення юнітів");
      }
    }

    function bindUnitModalActions() {
      const modal = document.getElementById("unitEditModal");
      const closeBtn = document.getElementById("unitEditClose");
      const cancelBtn = document.getElementById("unitEditCancel");
      const saveBtn = document.getElementById("unitEditSave");
      const clearUser = document.getElementById("clearUserUnits");
      const userInput = document.getElementById("userUnitsValue");

      if (closeBtn) closeBtn.addEventListener("click", closeUnitEditModal);
      if (cancelBtn) cancelBtn.addEventListener("click", closeUnitEditModal);
      if (saveBtn) saveBtn.addEventListener("click", applyUnitOverrides);
      if (modal) {
        modal.addEventListener("click", (event) => {
          if (event.target === modal) closeUnitEditModal();
        });
      }
      if (clearUser && userInput) {
        clearUser.addEventListener("change", () => {
          const allowUser = userInput.dataset.allowUser === "1";
          if (!allowUser) {
            clearUser.checked = false;
            return;
          }
          userInput.disabled = clearUser.checked;
        });
      }
    }

    function openTypeOverrideModal(scope, typeKey) {
      const modal = document.getElementById("typeOverrideModal");
      if (!modal) return;
      if (!activeCourse) {
        alert("Оберіть курс.");
        return;
      }
      if (scope === "user" && !activeUserId) {
        alert("Оберіть учасника.");
        return;
      }

      const baseRow =
        scope === "course" ? lastCourseRows.base[typeKey] : lastUserRows.base[typeKey];
      const overrides =
        scope === "course"
          ? normalizeProgressOverrides(activeCourse?.progressOverrides || {})
          : normalizeProgressOverrides(activeCourse?.progressUserOverrides?.[activeUserId] || {});
      const override = overrides[typeKey] || {};

      const nameEl = document.getElementById("typeOverrideName");
      const computedEl = document.getElementById("typeOverrideComputed");
      const taughtInput = document.getElementById("overrideTaughtValue");
      const attendedInput = document.getElementById("overrideAttendedValue");

      const label = baseRow?.label || typeKey || "—";
      if (nameEl) nameEl.textContent = label;
      if (computedEl) {
        const taught = baseRow ? courseProgressFormatValue(baseRow.taught) : "0";
        const attended = baseRow ? courseProgressFormatValue(baseRow.attended) : "0";
        const total = baseRow ? courseProgressFormatValue(baseRow.taught + baseRow.attended) : "0";
        computedEl.textContent = `Всього ${total}, Проведено ${taught}, Пройдено ${attended}`;
      }

      if (taughtInput) {
        taughtInput.value =
          Object.prototype.hasOwnProperty.call(override, "taught") ? override.taught : "";
      }
      if (attendedInput) {
        attendedInput.value =
          Object.prototype.hasOwnProperty.call(override, "attended") ? override.attended : "";
      }

      activeTypeForOverride = typeKey;
      activeOverrideScope = scope;
      modal.style.display = "flex";
    }

    function closeTypeOverrideModal() {
      const modal = document.getElementById("typeOverrideModal");
      if (!modal) return;
      modal.style.display = "none";
      activeTypeForOverride = null;
      activeOverrideScope = null;
    }

    async function saveTypeOverride() {
      if (!activeTypeForOverride || !activeCourse || !activeOverrideScope) return;
      const taughtInput = document.getElementById("overrideTaughtValue");
      const attendedInput = document.getElementById("overrideAttendedValue");

      const taughtValue = extractPositiveNumber(taughtInput?.value);
      const attendedValue = extractPositiveNumber(attendedInput?.value);

      if (taughtInput?.value !== "" && taughtValue === null) {
        alert("Некоректне значення для 'Проведено'.");
        return;
      }
      if (attendedInput?.value !== "" && attendedValue === null) {
        alert("Некоректне значення для 'Пройдено'.");
        return;
      }

      const next = {};
      if (taughtInput && taughtInput.value !== "" && taughtValue !== null) next.taught = taughtValue;
      if (attendedInput && attendedInput.value !== "" && attendedValue !== null) next.attended = attendedValue;

      try {
        const fetcher = window.adminFetch
          ? window.adminFetch
          : (url, opts) => fetch(url, Object.assign({ credentials: "include" }, opts));

        if (activeOverrideScope === "course") {
          const overrides = normalizeProgressOverrides(activeCourse?.progressOverrides || {});
          if (Object.keys(next).length) {
            overrides[activeTypeForOverride] = next;
          } else {
            delete overrides[activeTypeForOverride];
          }
          const res = await fetcher(`${API_BASE}/api/courses/${activeCourseId}`, {
            method: "PUT",
            headers: getAuthHeaders(),
            body: JSON.stringify({ progressOverrides: overrides }),
          });
          if (!res.ok) {
            const data = await res.json().catch(() => ({}));
            throw new Error(data.message || `HTTP ${res.status}`);
          }
          const updated = await res.json().catch(() => ({}));
          activeCourse.progressOverrides = updated.progressOverrides || overrides;
        } else {
          if (!activeUserId) {
            alert("Оберіть учасника.");
            return;
          }
          const progressUserOverrides = Object.assign({}, activeCourse?.progressUserOverrides || {});
          const userOverrides = normalizeProgressOverrides(progressUserOverrides[activeUserId] || {});
          if (Object.keys(next).length) {
            userOverrides[activeTypeForOverride] = next;
          } else {
            delete userOverrides[activeTypeForOverride];
          }
          if (Object.keys(userOverrides).length) {
            progressUserOverrides[activeUserId] = userOverrides;
          } else {
            delete progressUserOverrides[activeUserId];
          }
          const res = await fetcher(`${API_BASE}/api/courses/${activeCourseId}`, {
            method: "PUT",
            headers: getAuthHeaders(),
            body: JSON.stringify({ progressUserOverrides }),
          });
          if (!res.ok) {
            const data = await res.json().catch(() => ({}));
            throw new Error(data.message || `HTTP ${res.status}`);
          }
          const updated = await res.json().catch(() => ({}));
          activeCourse.progressUserOverrides = updated.progressUserOverrides || progressUserOverrides;
        }

        renderCourseTable();
        renderParticipantTable();
        closeTypeOverrideModal();
      } catch (err) {
        console.error("Помилка корекції юнітів:", err);
        alert(err.message || "Помилка корекції юнітів");
      }
    }

    async function resetTypeOverride() {
      if (!activeTypeForOverride || !activeCourse || !activeOverrideScope) return;

      try {
        const fetcher = window.adminFetch
          ? window.adminFetch
          : (url, opts) => fetch(url, Object.assign({ credentials: "include" }, opts));

        if (activeOverrideScope === "course") {
          const overrides = normalizeProgressOverrides(activeCourse?.progressOverrides || {});
          if (!overrides[activeTypeForOverride]) {
            closeTypeOverrideModal();
            return;
          }
          delete overrides[activeTypeForOverride];
          const res = await fetcher(`${API_BASE}/api/courses/${activeCourseId}`, {
            method: "PUT",
            headers: getAuthHeaders(),
            body: JSON.stringify({ progressOverrides: overrides }),
          });
          if (!res.ok) {
            const data = await res.json().catch(() => ({}));
            throw new Error(data.message || `HTTP ${res.status}`);
          }
          const updated = await res.json().catch(() => ({}));
          activeCourse.progressOverrides = updated.progressOverrides || overrides;
        } else {
          if (!activeUserId) {
            closeTypeOverrideModal();
            return;
          }
          const progressUserOverrides = Object.assign({}, activeCourse?.progressUserOverrides || {});
          const userOverrides = normalizeProgressOverrides(progressUserOverrides[activeUserId] || {});
          if (!userOverrides[activeTypeForOverride]) {
            closeTypeOverrideModal();
            return;
          }
          delete userOverrides[activeTypeForOverride];
          if (Object.keys(userOverrides).length) {
            progressUserOverrides[activeUserId] = userOverrides;
          } else {
            delete progressUserOverrides[activeUserId];
          }
          const res = await fetcher(`${API_BASE}/api/courses/${activeCourseId}`, {
            method: "PUT",
            headers: getAuthHeaders(),
            body: JSON.stringify({ progressUserOverrides }),
          });
          if (!res.ok) {
            const data = await res.json().catch(() => ({}));
            throw new Error(data.message || `HTTP ${res.status}`);
          }
          const updated = await res.json().catch(() => ({}));
          activeCourse.progressUserOverrides = updated.progressUserOverrides || progressUserOverrides;
        }

        renderCourseTable();
        renderParticipantTable();
        closeTypeOverrideModal();
      } catch (err) {
        console.error("Помилка скидання корекції:", err);
        alert(err.message || "Помилка скидання корекції");
      }
    }

    function bindTypeOverrideModalActions() {
      const modal = document.getElementById("typeOverrideModal");
      const closeBtn = document.getElementById("typeOverrideClose");
      const saveBtn = document.getElementById("typeOverrideSave");
      const resetBtn = document.getElementById("typeOverrideReset");

      if (closeBtn) closeBtn.addEventListener("click", closeTypeOverrideModal);
      if (saveBtn) saveBtn.addEventListener("click", saveTypeOverride);
      if (resetBtn) resetBtn.addEventListener("click", resetTypeOverride);
      if (modal) {
        modal.addEventListener("click", (event) => {
          if (event.target === modal) closeTypeOverrideModal();
        });
      }
    }

    function formatCoursePeriod(course) {
      const start = courseProgressFormatShortDate(courseProgressParseDate(course?.courseDates?.start));
      const end = courseProgressFormatShortDate(courseProgressParseDate(course?.courseDates?.end));
      if (start && end) return `${start} — ${end}`;
      return start || end || "—";
    }

    function rowsToMap(rows) {
      return rows.reduce((acc, row) => {
        acc[row.key] = row;
        return acc;
      }, {});
    }

    function buildRows(stats, extraStats) {
      const baseKeys = baseTypes.map((type) => type.key);
      const extraKeys = Object.keys(extraStats)
        .filter((key) => !baseKeys.includes(key))
        .sort((a, b) => a.localeCompare(b, "uk"));
      return [
        ...baseTypes.map((type) => stats[type.key]),
        ...extraKeys.map((key) => extraStats[key]),
      ];
    }

    function computeCourseBaseRows(course) {
      const stats = {};
      const extraStats = {};
      baseTypes.forEach((type) => courseProgressEnsureBucket(stats, type.key, type.label));

      if (Array.isArray(course?.units)) {
        course.units.forEach((unit) => {
          if (!unit || !unit.unitType) return;
          const occurrences = courseProgressGetUnitOccurrences(unit, course);
          if (!occurrences) return;
          const bucket =
            stats[unit.unitType] ||
            courseProgressEnsureBucket(extraStats, unit.unitType, unit.unitType);

          const amount = courseProgressGetUnitBaseAmount(unit) * occurrences;
          const members = Array.isArray(unit.members) ? unit.members : [];
          let hasTeacher = false;
          let hasAttendee = false;

          members.forEach((member) => {
            if (!member || !member.mode) return;
            if (member.mode === "проводив") {
              hasTeacher = true;
            } else {
              hasAttendee = true;
            }
          });

          if (!members.length) hasAttendee = true;
          if (hasTeacher) bucket.taught += amount;
          if (hasAttendee) bucket.attended += amount;
        });
      }

      if (course?.mainType === "Конференція") {
        const bucket =
          stats["Конференція"] ||
          courseProgressEnsureBucket(extraStats, "Конференція", "Конференція");
        if (course.creatorId) bucket.taught += 1;
        const participantsCount = Array.isArray(course.participants) ? course.participants.length : 0;
        if (participantsCount) bucket.attended += participantsCount;
      }

      return buildRows(stats, extraStats);
    }

    function computeParticipantBaseRows(course, userId) {
      const stats = {};
      const extraStats = {};
      baseTypes.forEach((type) => courseProgressEnsureBucket(stats, type.key, type.label));

      if (Array.isArray(course?.units)) {
        course.units.forEach((unit) => {
          if (!unit || !unit.unitType) return;
          const member = courseProgressGetUnitMember(unit, userId);
          if (!member) return;
          const occurrences = courseProgressGetUnitOccurrences(unit, course);
          if (!occurrences) return;
          const amount = courseProgressGetUnitAmount(unit, member) * occurrences;
          const bucket =
            stats[unit.unitType] ||
            courseProgressEnsureBucket(extraStats, unit.unitType, unit.unitType);

          if (member.mode === "проводив") {
            bucket.taught += amount;
          } else {
            bucket.attended += amount;
          }
        });
      }

      if (course?.mainType === "Конференція") {
        const bucket =
          stats["Конференція"] ||
          courseProgressEnsureBucket(extraStats, "Конференція", "Конференція");
        const isCreator = courseProgressIdsMatch(course.creatorId, userId);
        const isParticipant = Array.isArray(course.participants)
          ? course.participants.some((p) => courseProgressIdsMatch(p, userId))
          : false;
        if (isCreator) bucket.taught += 1;
        if (isParticipant) bucket.attended += 1;
      }

      return buildRows(stats, extraStats);
    }

    function computeGlobalUserBaseRows(userId) {
      const stats = {};
      const extraStats = {};
      baseTypes.forEach((type) => courseProgressEnsureBucket(stats, type.key, type.label));

      allCourses.forEach((course) => {
        if (!course) return;
        const courseStats = {};
        const ensureCourseBucket = (key, label) => {
          if (!courseStats[key]) {
            courseStats[key] = { key, label, taught: 0, attended: 0 };
          }
          return courseStats[key];
        };
        let hasParticipation = false;

        if (Array.isArray(course.units)) {
          course.units.forEach((unit) => {
            if (!unit || !unit.unitType) return;
            const member = courseProgressGetUnitMember(unit, userId);
            if (!member) return;
            hasParticipation = true;
            const occurrences = courseProgressGetUnitOccurrences(unit, course);
            if (!occurrences) return;
            const amount = courseProgressGetUnitAmount(unit, member) * occurrences;
            const bucket = ensureCourseBucket(unit.unitType, unit.unitType);
            if (member.mode === "проводив") {
              bucket.taught += amount;
            } else {
              bucket.attended += amount;
            }
          });
        }

        if (course.mainType === "Конференція") {
          const isCreator = courseProgressIdsMatch(course.creatorId, userId);
          const isParticipant = Array.isArray(course.participants)
            ? course.participants.some((p) => courseProgressIdsMatch(p, userId))
            : false;
          if (isCreator || isParticipant) {
            hasParticipation = true;
            const bucket = ensureCourseBucket("Конференція", "Конференція");
            if (isCreator) bucket.taught += 1;
            if (isParticipant) bucket.attended += 1;
          }
        }

        if (!hasParticipation) return;

        const courseRows = Object.values(courseStats);
        const courseOverrides = normalizeProgressOverrides(course?.progressOverrides || {});
        const userOverrides = normalizeProgressOverrides(
          course?.progressUserOverrides?.[userId] || {}
        );
        const mergedOverrides = mergeOverrides(courseOverrides, userOverrides);
        const adjustedRows = applyProgressOverrides(courseRows, mergedOverrides);

        adjustedRows.forEach((row) => {
          const bucket =
            stats[row.key] || courseProgressEnsureBucket(extraStats, row.key, row.label);
          bucket.taught += row.taught;
          bucket.attended += row.attended;
        });
      });

      const baseRows = buildRows(stats, extraStats);
      const globalOverrides = normalizeProgressOverrides(
        resolveUser(userId)?.progressOverrides || {}
      );
      return applyProgressOverrides(baseRows, globalOverrides);
    }

    function mergeOverrides(baseOverrides, userOverrides) {
      const result = Object.assign({}, baseOverrides || {});
      Object.keys(userOverrides || {}).forEach((key) => {
        const base = result[key] || {};
        result[key] = Object.assign({}, base, userOverrides[key] || {});
      });
      return result;
    }

    function renderCourseTable() {
      const body = document.getElementById("courseProgressBody");
      if (!body) return;
      if (!activeCourse) {
        body.innerHTML = '<tr><td colspan="5">Оберіть курс для перегляду.</td></tr>';
        lastCourseRows = { base: {}, display: {} };
        return;
      }

      const baseRows = computeCourseBaseRows(activeCourse);
      const courseOverrides = normalizeProgressOverrides(activeCourse?.progressOverrides || {});
      const displayRows = applyProgressOverrides(baseRows, courseOverrides).filter((row) => {
        if (row.taught + row.attended > 0) return true;
        return Object.prototype.hasOwnProperty.call(courseOverrides, row.key);
      });

      lastCourseRows = {
        base: rowsToMap(baseRows),
        display: rowsToMap(displayRows),
      };

      body.innerHTML = "";
      if (!displayRows.length) {
        body.innerHTML = '<tr><td colspan="5">Немає даних.</td></tr>';
        return;
      }
      displayRows.forEach((row) => {
        const total = row.taught + row.attended;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.label}</td>
          <td>${courseProgressFormatValue(total)}</td>
          <td>${courseProgressFormatValue(row.taught)}</td>
          <td>${courseProgressFormatValue(row.attended)}</td>
        `;
        const actionCell = document.createElement("td");
        const editBtn = document.createElement("button");
        editBtn.className = "more-btn progress-edit-btn";
        editBtn.type = "button";
        editBtn.textContent = "Коригувати";
        editBtn.addEventListener("click", () => openTypeOverrideModal("course", row.key));
        actionCell.appendChild(editBtn);
        tr.appendChild(actionCell);
        body.appendChild(tr);
      });
    }

    function renderParticipantTable() {
      const body = document.getElementById("participantProgressBody");
      if (!body) return;
      if (!activeCourse || !activeUserId) {
        body.innerHTML = '<tr><td colspan="5">Оберіть учасника для перегляду.</td></tr>';
        lastUserRows = { base: {}, display: {} };
        updateParticipantSummary(null);
        return;
      }

      const baseRows = computeParticipantBaseRows(activeCourse, activeUserId);
      const courseOverrides = normalizeProgressOverrides(activeCourse?.progressOverrides || {});
      const userOverrides = normalizeProgressOverrides(
        activeCourse?.progressUserOverrides?.[activeUserId] || {}
      );
      const mergedOverrides = mergeOverrides(courseOverrides, userOverrides);
      const displayRows = applyProgressOverrides(baseRows, mergedOverrides).filter((row) => {
        if (row.taught + row.attended > 0) return true;
        return Object.prototype.hasOwnProperty.call(mergedOverrides, row.key);
      });

      lastUserRows = {
        base: rowsToMap(baseRows),
        display: rowsToMap(displayRows),
      };

      body.innerHTML = "";
      if (!displayRows.length) {
        body.innerHTML = '<tr><td colspan="5">Немає даних.</td></tr>';
        return;
      }
      displayRows.forEach((row) => {
        const total = row.taught + row.attended;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.label}</td>
          <td>${courseProgressFormatValue(total)}</td>
          <td>${courseProgressFormatValue(row.taught)}</td>
          <td>${courseProgressFormatValue(row.attended)}</td>
        `;
        const actionCell = document.createElement("td");
        const editBtn = document.createElement("button");
        editBtn.className = "more-btn progress-edit-btn";
        editBtn.type = "button";
        editBtn.textContent = "Коригувати";
        editBtn.addEventListener("click", () => openTypeOverrideModal("user", row.key));
        actionCell.appendChild(editBtn);
        tr.appendChild(actionCell);
        body.appendChild(tr);
      });

      updateParticipantSummary(
        courseParticipants.find((u) => normalizeId(u) === activeUserId) || null
      );
    }

    function renderGlobalUserTable() {
      const body = document.getElementById("globalUserProgressBody");
      if (!body) return;
      if (!activeGlobalUserId) {
        body.innerHTML = '<tr><td colspan="4">Оберіть користувача для перегляду.</td></tr>';
        lastGlobalRows = { base: {}, display: {} };
        updateGlobalUserSummary(null);
        return;
      }

      const baseRows = computeGlobalUserBaseRows(activeGlobalUserId);
      const displayRows = baseRows.filter((row) => row.taught + row.attended > 0);

      lastGlobalRows = {
        base: rowsToMap(baseRows),
        display: rowsToMap(displayRows),
      };

      body.innerHTML = "";
      if (!displayRows.length) {
        body.innerHTML = '<tr><td colspan="4">Немає даних.</td></tr>';
        return;
      }
      displayRows.forEach((row) => {
        const total = row.taught + row.attended;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.label}</td>
          <td>${courseProgressFormatValue(total)}</td>
          <td>${courseProgressFormatValue(row.taught)}</td>
          <td>${courseProgressFormatValue(row.attended)}</td>
        `;
        body.appendChild(tr);
      });

      updateGlobalUserSummary(
        allUsers.find((u) => normalizeId(u) === activeGlobalUserId) || null
      );
    }

    function updateParticipantSummary(user) {
      const nameEl = document.getElementById("participantName");
      const emailEl = document.getElementById("participantEmail");
      if (!nameEl || !emailEl) return;
      if (!user) {
        nameEl.textContent = "—";
        emailEl.textContent = "—";
        return;
      }
      nameEl.textContent = getUserLabel(user) || "—";
      emailEl.textContent = user.email || "—";
    }

    function updateGlobalUserSummary(user) {
      const nameEl = document.getElementById("globalUserName");
      const emailEl = document.getElementById("globalUserEmail");
      if (!nameEl || !emailEl) return;
      if (!user) {
        nameEl.textContent = "—";
        emailEl.textContent = "—";
        return;
      }
      nameEl.textContent = getUserLabel(user) || "—";
      emailEl.textContent = user.email || "—";
    }

    function logoutUser() {
      try {
        localStorage.removeItem("user");
        ["token", "authToken", "jwt", "accessToken", "bearer"].forEach((k) =>
          localStorage.removeItem(k)
        );
      } catch (_) {}

      fetch(`${API_BASE}/api/users/logout`, { method: "POST", credentials: "include" }).catch(() => {});

      const back = encodeURIComponent(location.pathname + location.search);
      location.href = `admin-login.html?returnUrl=${back}`;
    }

    document.addEventListener("DOMContentLoaded", () => {
      const btn = document.getElementById("btnLogout");
      if (btn) btn.addEventListener("click", logoutUser);
    });
  </script>
</body>
</html>
